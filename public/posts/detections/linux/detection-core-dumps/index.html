<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Unveiling the Secrets of Linux Core Dumps</title>
    <meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta http-equiv="X-UA-Compatible" content="ie=edge" />

<link rel="stylesheet" href="/application.cb6d89cbee1604d12ceaf00b565c4e621520c5d0d92e5c7176db5d4d007cad21.css" integrity="sha256-y22Jy&#43;4WBNEs6vALVlxOYhUgxdDZLlxxdttdTQB8rSE=" />





<meta property="og:title" content="Unveiling the Secrets of Linux Core Dumps" />
<meta property="og:description" content="Unveiling the Secrets of Linux Core Dumps A Linux core dump, also known as a core dump file, is a file that captures the memory contents of a running process when it encounters a critical error or crashes. It is a snapshot of the process&rsquo;s memory at the time of the crash, including the values of variables, registers, and other relevant data. When a program crashes or terminates abnormally due to an error, the operating system generates a core dump file to help in debugging and understanding the cause of the crash." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://ardroci.pages.dev/posts/detections/linux/detection-core-dumps/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-05-28T19:47:08+01:00" />
<meta property="article:modified_time" content="2023-05-28T19:47:08+01:00" />

    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Unveiling the Secrets of Linux Core Dumps"/>
<meta name="twitter:description" content="Unveiling the Secrets of Linux Core Dumps A Linux core dump, also known as a core dump file, is a file that captures the memory contents of a running process when it encounters a critical error or crashes. It is a snapshot of the process&rsquo;s memory at the time of the crash, including the values of variables, registers, and other relevant data. When a program crashes or terminates abnormally due to an error, the operating system generates a core dump file to help in debugging and understanding the cause of the crash."/>

    
    
<meta name="description" content="Unveiling the Secrets of Linux Core Dumps" />


    

    
        
        
        
            
            
            
<script async src="https://www.googletagmanager.com/gtag/js?id=G-HLJKT0SE6G"></script>
<script>
var doNotTrack = false;
if (!doNotTrack) {
	window.dataLayer = window.dataLayer || [];
	function gtag(){dataLayer.push(arguments);}
	gtag('js', new Date());
	gtag('config', 'G-HLJKT0SE6G', { 'anonymize_ip': false });
}
</script>

        

        
        

        
        

        
        
        
    




</head>

  <body class="type-posts kind-page" data-spy="scroll" data-target="#TableOfContents" data-offset="80">
    <div class="container-fluid bg-dimmed wrapper">
      
      
    












<nav class="navbar navbar-expand-xl top-navbar final-navbar shadow">
  <div class="container">
      <button class="navbar-toggler navbar-light" id="sidebar-toggler" type="button">
      <span class="navbar-toggler-icon"></span>
    </button>
    <a class="navbar-brand" href="/">
      4rdr0ci</a>
    <button class="navbar-toggler navbar-light" id="toc-toggler" type="button">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div class="collapse navbar-collapse lang-selector" id="top-nav-items">
      <ul class="navbar-nav ml-auto">
      
      
        <li class="nav-item dropdown">
<a class="nav-link dropdown-toggle"  href="#" id="themeSelector" role="button"
  data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
  <img id="navbar-theme-icon-svg" src="/icons/moon-svgrepo-com.svg" width=20 alt="Dark Theme">
</a>
<div id="themeMenu" class="dropdown-menu dropdown-menu-icons-only" aria-labelledby="themeSelector">
  <a class="dropdown-item nav-link" href="#" data-scheme="light">
    <img class="menu-icon-center" src="/icons/sun-svgrepo-com.svg" width=20 alt="Light Theme">
  </a>
  <a class="dropdown-item nav-link" href="#" data-scheme="dark">
    <img class="menu-icon-center" src="/icons/moon-svgrepo-com.svg" width=20 alt="Dark Theme">
  </a>
  <a class="dropdown-item nav-link" href="#" data-scheme="system">
    <img class="menu-icon-center" src="/icons/computer-svgrepo-com.svg" width=20 alt="System Theme">
  </a>
</div>
</li>

      
      </ul>
    </div>
  </div>
  
  
  
</nav>



      
      
  <section class="sidebar-section" id="sidebar-section">
    <div class="sidebar-holder">
      <div class="sidebar" id="sidebar">
        <form class="mx-auto" method="get" action="/search">
          <input type="text" name="keyword" value="" placeholder="Search" data-search="" id="search-box" />
        </form>
        <div class="sidebar-tree">
          <ul class="tree" id="tree">
            <li id="list-heading"><a href="/posts/" data-filter="all">Posts</a></li>
            <div class="subtree">
                
  
  
  
  
    
    
  
  
    
    <li>
      <i class="fas fa-minus-circle"></i><a class="active" href="/posts/detections/">Detection</a>
      
      <ul class="active">
        
  
  
  
  
    
    
  
  
    
    <li>
      <i class="fas fa-minus-circle"></i><a class="active" href="/posts/detections/linux/">Linux</a>
      
      <ul class="active">
        
  
  
  
  
  
    
    <li><a class="" href="/posts/detections/linux/kernel-stack/" title="Linux kernel stack trace">Linux kernel stack trace</a></li>
  

  
  
  
  
    
    
  
  
    
    <li><a class="active" href="/posts/detections/linux/detection-core-dumps/" title="Unveiling the Secrets of Linux Core Dumps">Unveiling the Secrets of Linux Core Dumps</a></li>
  


      </ul>
    </li>
  


      </ul>
    </li>
  


            </div>
          </ul>
        </div>
      </div>
    </div>
  </section>


      
      
<section class="content-section" id="content-section">
  <div class="content">
    <div class="container p-0 read-area">
      
      <div class="hero-area col-sm-12" id="hero-area" style='background-image: url(/posts/detections/linux/detection-core-dumps/password-with-hand-holding-tweezers-binary-code.jpg);'>
      </div>

      
      <div class="page-content">
        <div class="author-profile ml-auto align-self-lg-center">
          <img class="rounded-circle" src='/images/author/john_hu7f9991f5b5d471ecdfc6cff3db1a9fe6_6397_120x120_fit_box_3.png' alt="Author Image">
          <h5 class="author-name">4rdr0ci</h5>
          <p>Sunday, May 28, 2023</p>
        </div>

        <div class="title">
          <h1>Unveiling the Secrets of Linux Core Dumps</h1>
        </div>
        
        <div class="taxonomy-terms">
          <ul style="padding-left: 0;">
            
            
            <li class="rounded"><a href="/tags/threat-detection/" class="btn, btn-sm">Threat Detection</a></li>
            
            
            <li class="rounded"><a href="/tags/linux/" class="btn, btn-sm">Linux</a></li>
            
            
            <li class="rounded"><a href="/tags/core-dumps/" class="btn, btn-sm">Core Dumps</a></li>
            
          </ul>
        </div>
        
        <div class="post-content" id="post-content">
          <h2 id="unveiling-the-secrets-of-linux-core-dumps">Unveiling the Secrets of Linux Core Dumps</h2>
<p>A Linux core dump, also known as a core dump file, is a file that captures the memory contents of a running process when it encounters a critical error or crashes. It is a snapshot of the process&rsquo;s memory at the time of the crash, including the values of variables, registers, and other relevant data. When a program crashes or terminates abnormally due to an error, the operating system generates a core dump file to help in debugging and understanding the cause of the crash. This file contains valuable information that can be analyzed to diagnose the issue and fix the software or identify vulnerabilities.</p>
<p>The core dump file is typically written to disk in a binary format but it can also be passed to a helper program (such as systemd-coredump(8)) for further processing. It contains the memory image of the crashed process and includes the program&rsquo;s code, stack frames, heap data, and other relevant information. By examining the core dump, developers and security professionals can gain insights into the state of the program at the time of the crash, helping them identify bugs, memory corruption issues, or security vulnerabilities.</p>
<p>To analyze a core dump file, various debugging tools and techniques can be used. These tools allow the examination of memory regions, registers, and stack frames to understand the flow of the program before it crashed. Debuggers like GDB (GNU Debugger) are commonly used to load the core dump file and perform detailed analysis, including inspecting variables, stepping through the code, and examining memory regions.</p>
<p>Security detection engineers may utilize core dumps as part of their investigations when analyzing incidents related to software crashes, exploits, or malicious activities. By examining the core dump, they can gather crucial information about the exploit or identify potential vulnerabilities that were exploited.</p>
<p>It&rsquo;s worth noting that core dumps may contain sensitive information, such as passwords or encryption keys, depending on the state of the crashed process. Therefore, it&rsquo;s important to handle core dump files with care, restrict access to authorized personnel, and ensure they are securely stored to prevent unauthorized access to sensitive data.</p>
<h2 id="exploring-threat-actor-exploitation-of-core-dumps">Exploring Threat Actor Exploitation of Core Dumps</h2>
<p>In general, a core dump file itself does not pose a direct risk when it comes to threat actors using it maliciously. However, threat actors can potentially leverage the information contained within a core dump to aid in their attacks or exploit vulnerabilities. Here are a few scenarios where a threat actor might find value in a core dump:</p>
<ol>
<li>
<p>Information Disclosure: If the core dump file contains sensitive information, such as passwords, API keys, or cryptographic keys, a threat actor could analyze the dump to extract and exploit that data.</p>
</li>
<li>
<p>Exploit Analysis: By examining a core dump, threat actors can gain insights into the inner workings of a crashed process. They can analyze the memory contents to identify vulnerabilities, memory corruption issues, or other weaknesses that could be exploited for their malicious activities.</p>
</li>
<li>
<p>Reverse Engineering: A threat actor may use a core dump file to reverse engineer the software and understand its internal structure, algorithms, or proprietary protocols. This knowledge can be leveraged to craft more sophisticated attacks or develop exploits targeting specific vulnerabilities.</p>
</li>
<li>
<p>Debugging Exploits: Core dumps provide detailed information about the state of a crashed process, including register values, stack traces, and memory contents. Threat actors can use this information to debug their exploits, fine-tune their attack techniques, or identify potential weaknesses to bypass security measures.</p>
</li>
</ol>
<p>To mitigate the risks associated with core dumps falling into the wrong hands, it&rsquo;s crucial to follow security best practices:</p>
<ol>
<li>
<p>Restrict Access: Limit access to core dump files to authorized personnel only. Implement strict access controls, permissions, and user authentication mechanisms to prevent unauthorized access.</p>
</li>
<li>
<p>Secure Storage: Store core dump files in a secure location with proper encryption and access controls. Regularly monitor and audit access to these files to detect any suspicious activities.</p>
</li>
<li>
<p>Sanitize Sensitive Data: Before sharing or analyzing core dump files, ensure sensitive information, such as passwords or encryption keys, is removed or obfuscated to prevent potential exploitation.</p>
</li>
<li>
<p>Incident Response: If a core dump is part of a security incident, follow established incident response procedures. Analyze the core dump in a controlled environment and take appropriate actions to remediate vulnerabilities, patch software, or enhance security controls.</p>
</li>
</ol>
<p>By understanding the potential risks and taking appropriate security measures, organizations can help minimize the chances of threat actors exploiting core dump files for their malicious activities.</p>
<h2 id="unveiling-threat-actor-techniques-how-they-force-core-dumps">Unveiling Threat Actor Techniques: How They Force Core Dumps</h2>
<p>In the realm of cybersecurity, threat actors continuously devise new methods to achieve their malicious objectives. One technique they may employ is to force a core dump on a targeted system. A core dump is a snapshot of a process&rsquo;s memory at the time of its abnormal termination or crash. In this blog post, we will explore how threat actors can force core dumps and the potential risks associated with these actions.</p>
<p><strong>Method 1: Exploiting Vulnerabilities</strong>
One common approach utilized by threat actors involves exploiting software vulnerabilities. By identifying weaknesses in applications or the underlying operating system, they can trigger crashes or abnormal terminations intentionally. Vulnerabilities such as memory corruption, buffer overflow, or programming errors may serve as entry points. Through targeted exploitation, threat actors can force a process to crash, ultimately leading to the generation of a core dump.</p>
<p><strong>Method 2: Resource Exhaustion</strong>
Another technique is to exhaust system resources deliberately. By overwhelming a specific process or the system as a whole, threat actors can cause a crash scenario. Excessive consumption of memory, CPU, or other critical resources can result in an abnormal termination, triggering the creation of a core dump.</p>
<p><strong>Method 3: Signal Injection</strong>
Threat actors may manipulate vulnerable applications to generate specific signals, such as the <code>SIGSEGV</code> (segmentation fault) signal. This signal, when injected, causes a process to terminate abruptly. By exploiting the application&rsquo;s vulnerability to signal injection, threat actors can induce a crash scenario and prompt the system to generate a core dump.</p>
<p><strong>Method 4: Debugging Tools Abuse</strong>
If a threat actor gains unauthorized access to a system or compromises a privileged account, they may abuse debugging tools that allow core dump generation. Debuggers like GDB (GNU Debugger) or similar utilities can be misused to force crashes, intercept signals, or manipulate the target process&rsquo;s behavior. Through such manipulation, threat actors can trigger core dump creation.</p>
<h2 id="mitigation-strategies">Mitigation Strategies</h2>
<p>To effectively eradicate the threat associated with core dump files falling into the wrong hands, it is important to implement a combination of preventive measures and incident response practices. Here are some steps you can take:</p>
<ol>
<li>
<p>Access Controls: Implement strong access controls to restrict access to core dump files. Only authorized personnel should have permission to access and analyze these files. Regularly review and update access privileges to ensure they align with the principle of least privilege.</p>
</li>
<li>
<p>Secure Storage and Encryption: Store core dump files in a secure location, such as a dedicated and protected directory or server, with proper encryption in place. Encryption adds an extra layer of protection, especially if the files are stored or transferred over untrusted networks.</p>
</li>
<li>
<p>Data Sanitization: Before sharing or analyzing core dump files, ensure sensitive data within the dumps, such as passwords, keys, or personally identifiable information (PII), is removed or obfuscated. This can be achieved by scrubbing or sanitizing the dumps using appropriate tools or techniques.</p>
</li>
<li>
<p>Incident Response Planning: Develop a comprehensive incident response plan specifically tailored to address incidents involving core dump files. This plan should outline the steps to be taken when a core dump is compromised or potentially accessed by unauthorized parties.</p>
</li>
<li>
<p>Monitoring and Detection: Implement robust monitoring and detection mechanisms to identify any unauthorized access attempts or suspicious activities related to core dump files. This can include intrusion detection systems, log analysis, and security event monitoring.</p>
</li>
<li>
<p>Regular Auditing and Review: Conduct regular audits and reviews of the access logs, storage locations, and security measures related to core dump files. This helps ensure that security controls are functioning as intended and any vulnerabilities or misconfigurations are promptly addressed.</p>
</li>
<li>
<p>Employee Awareness and Training: Provide training and awareness programs to employees involved in handling core dump files. Educate them about the importance of securing and handling these files properly, including the risks associated with their exposure and the best practices to mitigate those risks.</p>
</li>
</ol>
<h2 id="threat-detection-rules">Threat Detection Rules</h2>
<p>Rather than emphasizing commands that generate core dumps, shift your focus to the list of signals that trigger core dump creation in a process, e.g. SIGABRT. <sup>[2, 3]</sup>. However, not all monitoring tools are equipped to handle such intricate levels of detail.
As an alternative, you can consider /proc/self/coredump_filter. The /proc/self/coredump_filter file is used in Linux systems to control the types of information that are included in a core dump file when a process crashes. It allows a process to specify which memory segments and resources should be included or excluded from the core dump. Before generating the core dump, the operating system checks the settings in the /proc/self/coredump_filter file to determine which memory segments and resources should be included in the core dump, e.g. openat(AT_FDCWD, &ldquo;/proc/1688715/coredump_filter&rdquo;, O_RDONLY|O_CLOEXEC) = 14. The operating system reads the bitmask specified in the file to understand the process&rsquo;s preferences for the contents of the core dump. Based on the settings in the coredump_filter file, the operating system includes or excludes the corresponding memory segments and resources when creating the core dump file.</p>
<h3 id="auditd">Auditd</h3>
<p>To detect when a process reads its own core dump filter settings, we will leverage the power of auditd, the Linux auditing framework. Follow these steps to create the FIM rule:</p>
<ol>
<li>Open the audit rules configuration file using a text editor:</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo nano /etc/audit/rules.d/audit.rules
</span></span></code></pre></div><ol start="2">
<li>Add the following line to the file:</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>-w /proc/self/coredump_filter -p r -k coredump_filter_read
</span></span></code></pre></div><p>This rule instructs auditd to monitor the file /proc/self/coredump_filter for read operations (-p r). When a process reads this file, an audit event will be generated and labeled with the key coredump_filter_read (-k coredump_filter_read).
3. Save the file and exit the text editor.</p>
<ol start="4">
<li>Restart the auditd service to apply the changes:</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo service auditd restart
</span></span></code></pre></div><h3 id="falco">Falco</h3>
<p>Falco is a powerful open-source cloud-native runtime security tool that enables real-time threat detection and response. Here&rsquo;s an example of a Falco rule that can detect when a process reads the /proc/self/coredump_filter file:</p>
<ol>
<li>Open the falco rules configuration file using a text editor:</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo nano /etc/falco/falco_rules.local.yaml
</span></span></code></pre></div><ol start="2">
<li>Add the following macro and rule to the file:</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span>- <span style="color:#f92672">macro</span>: <span style="color:#ae81ff">open_read</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">condition</span>: <span style="color:#ae81ff">(evt.type in (open,openat,openat2) and evt.is_open_read=true and fd.typechar=&#39;f&#39; and fd.num&gt;=0)</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>- <span style="color:#f92672">rule</span>: <span style="color:#ae81ff">Core dump</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">desc</span>: &gt;<span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    An attempt to read core dump.</span>    
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">enabled</span>: <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">condition</span>: &gt;<span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    evt.category=file 
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    and open_read
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    and fd.name = &#34;/proc/self/coredump_filter&#34;</span>    
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">output</span>: |<span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    # Event information
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    evt_rawres=%evt.rawres, evt_type=%evt.type, evt_dir=%evt.dir, syscall_type=%syscall.type, evt_category=%evt.category, evt_args=%evt.args, 
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    # Process information
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    proc_pid=%proc.pid, proc_exe=%proc.exe, proc_name=%proc.name, proc_args=%proc.args, proc_cmdline=%proc.cmdline, proc_exeline=%proc.exeline, proc_cwd=%proc.cwd, proc_nthreads=%proc.nthreads, proc_nchilds=%proc.nchilds, proc_ppid=%proc.ppid, proc_pname=%proc.pname, proc_pcmdline=%proc.pcmdline, proc_apid_2=%proc.apid[2], proc_aname_2=%proc.aname[2], proc_apid_3=%proc.apid[3], proc_aname_3=%proc.aname[3], proc_apid_4=%proc.apid[4], proc_aname_4=%proc.aname[4], proc_loginshellid=%proc.loginshellid, proc_duration=%proc.duration, proc_fdopencount=%proc.fdopencount, proc_vmsize=%proc.vmsize, proc_sid=%proc.sid, proc_sname=%proc.sname, proc_tty=%proc.tty, proc_exepath=%proc.exepath, proc_vpgid=%proc.vpgid, proc_is_exe_writable=%proc.is_exe_writable,
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    # Threat information
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    #thread_cap_permitted=%thread.cap_permitted, thread_cap_inheritable=%thread.cap_inheritable, thread_cap_effective=%thread.cap_effective,
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    # File descriptor information
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    fd_num=%fd.num, fd.type=%fd.type, fd_name=%fd.name, 
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    # User and group information
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    user_uid=%user.uid, user_name=%user.name, user_homedir=%user.homedir, user_shell=%user.shell, user_loginuid=%user.loginuid, user_loginname=%user.loginname, group_gid=%group.gid, group_name=%group.name</span>    
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">priority</span>: <span style="color:#ae81ff">WARNING</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">tags</span>: [<span style="color:#ae81ff">filesystem, mitre_credential_access, mitre_discovery]</span>
</span></span></code></pre></div><ol start="3">
<li>
<p>Save the file and exit the text editor.</p>
</li>
<li>
<p>Restart the falco service to apply the changes:</p>
</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo service falco restart
</span></span></code></pre></div><blockquote>
<p><strong>Note</strong>
Make sure to configure Falco properly to ensure it captures the necessary system events and performs the desired detection. Adjust the rule according to your specific environment and monitoring needs.</p>
</blockquote>
<h2 id="validation">Validation</h2>
<p>Once you have implemented a FIM rule to detect process access to the /proc/self/coredump_filter file, it is essential to verify that the detection logic is functioning correctly. In this section, we will walk you through the steps to test the detection logic of the rule and ensure that it generates the expected output when a process reads the core dump filter file.</p>
<p><strong>Step 1: Preparing the Environment</strong>
Before testing the rule, ensure that you have Falco or auditd properly installed and running on your system. Refer to the Falco documentation for guidance on installation and configuration specific to your environment.</p>
<p><strong>Step 2: Performing the Test</strong>
To test the detection logic, execute the following commands:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sleep <span style="color:#ae81ff">300</span> &amp;
</span></span><span style="display:flex;"><span>PID<span style="color:#f92672">=</span>$!
</span></span><span style="display:flex;"><span>kill -s SIGSEGV <span style="color:#e6db74">&#34;</span>$PID<span style="color:#e6db74">&#34;</span>
</span></span></code></pre></div><p>By following these steps, you can test the detection logic of your rule and validate its effectiveness in detecting access . Regularly testing and validating your security monitoring rules is crucial to ensure that your system remains protected against unauthorized or suspicious activities.</p>
<h2 id="bed-time-reading">Bed Time Reading</h2>
<ol>
<li><a href="https://wiki.archlinux.org/title/Core_dump" target="_blank" rel="noopener">https://wiki.archlinux.org/title/Core_dump</a></li>
<li><a href="https://man7.org/linux/man-pages/man5/core.5.html" target="_blank" rel="noopener">https://man7.org/linux/man-pages/man5/core.5.html</a></li>
<li><a href="https://man7.org/linux/man-pages/man7/signal.7.html" target="_blank" rel="noopener">https://man7.org/linux/man-pages/man7/signal.7.html</a></li>
<li><a href="https://linux-audit.com/understand-and-configure-core-dumps-work-on-linux/#disable-core-dumps" target="_blank" rel="noopener">https://linux-audit.com/understand-and-configure-core-dumps-work-on-linux/#disable-core-dumps</a></li>
</ol>

        </div>

        
        <div class="row pl-3 pr-3">
        
        <div class="col-md-6 share-buttons">
        
            <strong>Share on:</strong>
            
            
                <a class="btn btn-sm twitter-btn" href="https://twitter.com/share?url=https%3a%2f%2fardroci.pages.dev%2fposts%2fdetections%2flinux%2fdetection-core-dumps%2f&text=Unveiling%20the%20Secrets%20of%20Linux%20Core%20Dumps&via=4rdr0ci" target="_blank">
                  <i class="fab fa-twitter"></i>
                </a>
            
            
                <a  class="btn btn-sm reddit-btn" href="https://reddit.com/submit?url=https%3a%2f%2fardroci.pages.dev%2fposts%2fdetections%2flinux%2fdetection-core-dumps%2f&title=Unveiling%20the%20Secrets%20of%20Linux%20Core%20Dumps" target="_blank">
                  <i class="fab fa-reddit"></i>
                </a>
            
            
            
            
            
             
            
            
                <a class="btn btn-sm email-btn" href="mailto:?subject=Unveiling%20the%20Secrets%20of%20Linux%20Core%20Dumps&body=https%3a%2f%2fardroci.pages.dev%2fposts%2fdetections%2flinux%2fdetection-core-dumps%2f" target="_blank">
                  <i class="fas fa-envelope-open-text"></i>
                </a>
            
          
          </div>

        
        
          
            
          
          <div class="col-md-6 btn-improve-page">
             
               <a href="https://github.com/ardroci/ardroci.dev/edit/main/content/posts/detections/linux/detection-core-dumps/index.md" title="Improve this page" target="_blank" rel="noopener">
            
                <i class="fas fa-code-branch"></i>
                Improve this page
              </a>
          </div>
        
        </div>



      
      <hr />
        







  





  
  

  
    
    
  
  


<div class="row next-prev-navigator">
  
    <div class="col-md-6 previous-article">
      <a href="/posts/detections/linux/kernel-stack/" title="Linux kernel stack trace" class="btn btn-outline-info">
        <div><i class="fas fa-chevron-circle-left"></i> Prev</div>
        <div class="next-prev-text">Linux kernel stack trace</div>
      </a>
    </div>
  
  
</div>

      <hr />

      
      

      
      

      </div>
    </div>
  </div>
  
  <a id="scroll-to-top" class="btn"><i class="fas fa-chevron-circle-up"></i></a>
  
</section>


      
      
  <section class="toc-section" id="toc-section">
    
    <div class="toc-holder">
      <h5 class="text-center pl-3">Table of Contents</h5>
      <hr>
      <div class="toc">
        <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#unveiling-the-secrets-of-linux-core-dumps">Unveiling the Secrets of Linux Core Dumps</a></li>
        <li><a href="#exploring-threat-actor-exploitation-of-core-dumps">Exploring Threat Actor Exploitation of Core Dumps</a></li>
        <li><a href="#unveiling-threat-actor-techniques-how-they-force-core-dumps">Unveiling Threat Actor Techniques: How They Force Core Dumps</a></li>
        <li><a href="#mitigation-strategies">Mitigation Strategies</a></li>
        <li><a href="#threat-detection-rules">Threat Detection Rules</a>
          <ul>
            <li><a href="#auditd">Auditd</a></li>
            <li><a href="#falco">Falco</a></li>
          </ul>
        </li>
        <li><a href="#validation">Validation</a></li>
        <li><a href="#bed-time-reading">Bed Time Reading</a></li>
      </ul>
    </li>
  </ul>
</nav>
      </div>
    </div>
    
  </section>

    </div>

    
    













    <script src="/application.fed5505c7d1c555b2a3fef58d66ee0a15aac6ffc1a12ebc3b1349ea0050167b8.js" integrity="sha256-/tVQXH0cVVsqP&#43;9Y1m7goVqsb/waEuvDsTSeoAUBZ7g=" defer></script>



    
     

    
</body>
</html>
