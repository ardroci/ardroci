[{"section":"Blog","slug":"/blog/linux-fileless-malware/","title":"Invisible Intruders - Unmasking the Stealthy World of Fileless Malware","description":"","date":"June 4, 2023","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/linux-fileless-malware/fileless-malware_hu4bb4099eb49025c2fa6e185446aa6f86_93634_420x0_resize_q80_h2_lanczos.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"280\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/linux-fileless-malware\\/fileless-malware_hu4bb4099eb49025c2fa6e185446aa6f86_93634_420x0_resize_q80_lanczos.jpeg';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/linux-fileless-malware/fileless-malware_hu4bb4099eb49025c2fa6e185446aa6f86_93634_100x100_fill_q80_h2_lanczos_smart1.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/linux-fileless-malware\\/fileless-malware_hu4bb4099eb49025c2fa6e185446aa6f86_93634_100x100_fill_q80_lanczos_smart1.jpeg';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"Security","tags":"Threat Detection, Linux, Malware","content":"In the ever-evolving landscape of cyber threats, malware continues to be a significant concern for individuals and organizations alike. Traditional malware often relies on files to carry out malicious activities. However, a couple of years ago a new breed of malware known as \u0026ldquo;fileless malware\u0026rdquo; has emerged, posing a formidable challenge to cybersecurity professionals. In this blog post, we will explore the concept of fileless malware, discuss threat actors utilizing it, delve into their techniques, and discover methods to detect fileless malware on Linux systems.\nWhat is Fileless Malware? Fileless malware refers to a type of malicious software that does not rely on traditional file-based components to infect and persist on a victim\u0026rsquo;s system. Unlike conventional malware that typically relies on executable files or scripts stored on disk, fileless malware operates by leveraging legitimate system tools and processes already present on the target system. It resides solely in the computer\u0026rsquo;s memory or uses existing system utilities to execute malicious actions, making it difficult to detect and eradicate.\nFileless malware takes advantage of various techniques to carry out its malicious activities while minimizing its footprint on the compromised system. Here are some common characteristics and techniques associated with fileless malware:\nMemory-based Execution: Fileless malware operates in the computer\u0026rsquo;s memory, leveraging scripting languages, macros, or other memory-resident techniques to execute its payload. By avoiding disk-based files, it reduces the likelihood of detection by traditional antivirus software that primarily scans for file-based threats.\nLiving off the Land: Fileless malware exploits trusted system tools, processes, and utilities already present on the compromised system. It abuses legitimate software such as PowerShell, Windows Management Instrumentation (WMI), or command-line interpreters to carry out its malicious activities. This technique makes it challenging to distinguish between normal and malicious system behavior.\nCode Injection and Registry Persistence: Instead of dropping files on disk, fileless malware injects its code directly into legitimate processes running in memory. It can also modify system registries to achieve persistence, ensuring that the malware remains active even after a system reboot.\nExploiting Vulnerabilities: Fileless malware often exploits vulnerabilities in software or operating systems to gain initial access to a system. It can use techniques like remote code execution, privilege escalation, or phishing attacks to deliver the payload and establish a foothold.\nCredential Theft and Lateral Movement: Once fileless malware infects a system, it focuses on extracting sensitive information, such as usernames, passwords, or cryptographic keys. It may use techniques like keylogging, memory scraping, or pass-the-hash attacks to harvest credentials. Subsequently, it can leverage these credentials to move laterally across the network, infecting additional systems.\nFileless malware poses significant challenges for traditional security solutions due to its evasive nature and reliance on legitimate system components. Detecting and mitigating fileless malware requires a multi-layered approach that includes behavioral analysis, anomaly detection, monitoring of system activities, and the use of specialized security tools designed to detect memory-based threats.\nUnmasking the Culprits: Threat Actor Groups Leveraging Fileless Malware Fileless malware has become a favorite weapon in the arsenals of various threat actor groups, allowing them to launch stealthy and sophisticated attacks. In this section, we\u0026rsquo;ll delve into some of the notable threat actor groups that have been leveraging fileless malware as part of their nefarious activities.\nAPT28 (Fancy Bear): Known for its association with the Russian government, APT28, also known as Fancy Bear, has demonstrated advanced capabilities in carrying out cyber espionage campaigns. This threat actor group has been observed employing fileless malware to infiltrate high-profile targets and compromise sensitive information. Their sophisticated techniques make detection and attribution challenging.\nLazarus Group: Hailing from North Korea, the Lazarus Group has gained infamy for its involvement in high-profile cyber attacks. This threat actor group has adopted fileless malware as a stealthy approach to breach financial institutions and cryptocurrency exchanges. Their goal is often financial gain, and they employ advanced tactics to evade detection and cover their tracks.\nAPT32 (OceanLotus): APT32, also known as OceanLotus, is a sophisticated threat actor group originating from Vietnam. This group primarily targets Southeast Asian countries, with a focus on government entities, dissidents, and corporate organizations. APT32 has been observed utilizing fileless malware in their campaigns, allowing them to bypass traditional security measures and maintain persistence within compromised systems.\nAPT34 (OilRig): Hailing from Iran, APT34, also known as OilRig, is a well-known threat actor group that conducts cyber espionage activities. This group has been attributed to various campaigns targeting critical infrastructure, energy sectors, and government organizations. APT34 has incorporated fileless malware into its tactics, enabling them to infiltrate networks, gather intelligence, and maintain long-term access.\nAPT40 (Periscope): APT40, also referred to as Periscope, is a Chinese threat actor group with a focus on maritime industries, specifically targeting entities involved in the South China Sea disputes. This group has been observed employing fileless malware to compromise maritime organizations, gaining access to sensitive data and strategic information. Their activities pose significant risks to national security and regional stability.\nThese are just a few examples of threat actor groups that have embraced fileless malware as part of their malicious campaigns. The evolving landscape of cyber threats necessitates continuous vigilance and proactive defense measures to mitigate the risks posed by these sophisticated adversaries.\nSneaky Techniques: How Threat Actor Groups Utilize Fileless Malware Fileless malware has become an integral component of the toolkit used by various threat actor groups. In this section, we\u0026rsquo;ll uncover the sneaky techniques employed by these adversaries when utilizing fileless malware, shedding light on their modus operandi and the challenges faced by security professionals.\nLiving Off the Land: One of the primary techniques employed by threat actors using fileless malware is \u0026ldquo;living off the land.\u0026rdquo; This involves leveraging legitimate processes, tools, and functionalities already present in the targeted system to carry out their malicious activities. By exploiting trusted applications and system utilities, such as PowerShell, Windows Management Instrumentation (WMI), or Linux command-line tools, threat actors can execute malicious code directly in memory, leaving little to no trace on the file system.\nExploiting Vulnerabilities: Threat actor groups also capitalize on software vulnerabilities to deploy fileless malware. They actively search for security flaws in popular applications, operating systems, or even firmware, allowing them to exploit these weaknesses and gain unauthorized access. Once inside the system, they can inject their malicious code into legitimate processes or memory areas without relying on traditional file-based payloads.\nScript-Based Attacks: Scripting languages like PowerShell and JavaScript provide threat actors with powerful capabilities to execute commands and automate tasks. These languages are often used to deliver fileless malware payloads, as they can run directly in memory, evading traditional antivirus and endpoint detection mechanisms. By embedding malicious scripts within seemingly harmless documents or leveraging social engineering techniques, threat actors trick users into executing the scripts, initiating the infection chain.\nMemory Injection and Code Staging: Another technique utilized by threat actors involves memory injection and code staging. Instead of relying on traditional file-based payloads, they inject their malicious code directly into the memory space of legitimate processes. This enables them to execute their code within the context of trusted applications, making detection and analysis more challenging. By using code staging techniques, threat actors can further obfuscate their activities by encrypting or decrypting their payloads in memory, adding an extra layer of complexity.\nFileless Persistence Mechanisms: Maintaining persistence is crucial for threat actors to ensure prolonged access to compromised systems. Fileless malware allows them to establish persistence without leaving traces on the file system. They achieve this by employing various techniques, such as registry modifications, scheduled tasks, or service hijacking, to ensure their malicious code is executed during system startup or at specific intervals. By leveraging these fileless persistence mechanisms, threat actors can maintain control over the compromised system for an extended period.\nDetecting and mitigating fileless malware poses significant challenges for security professionals. Traditional antivirus solutions often rely on file-based scanning, making them ineffective against fileless attacks. To combat these stealthy threats, specialized security tools and techniques, such as behavior-based detection, memory analysis, and anomaly detection, are crucial for detecting and responding to fileless malware incidents.\nIn the next section, we will explore strategies and best practices to help organizations enhance their defenses against fileless malware attacks, empowering them to proactively protect their systems and data.\nMitigating Fileless Malware in Your Linux Environment: Best Practices As fileless malware continues to evolve and pose a significant threat to systems, it\u0026rsquo;s crucial to implement effective mitigation strategies specifically tailored for Linux environments. Linux, being a popular operating system in both server and desktop environments, requires diligent measures to protect against fileless malware attacks. In this section, we will explore some key practices to help you mitigate fileless malware in your Linux environment.\nHarden Your Linux System: To mitigate fileless malware attacks, start by hardening your Linux system\u0026rsquo;s security posture. This includes:\nRegularly updating your operating system and installed software to ensure you have the latest security patches. Vulnerabilities in software components can be exploited by fileless malware to gain access to the system.\nDisable unnecessary services and protocols to reduce the attack surface. Only enable the services that are essential for your system\u0026rsquo;s functionality.\nEmploy strong authentication mechanisms, such as multi-factor authentication (MFA), to prevent unauthorized access to your system.\nMonitor System Activities: Implementing robust monitoring and logging capabilities is crucial for detecting and responding to fileless malware. Consider the following practices:\nEnable auditing and logging features provided by your Linux distribution. This includes logging process execution, file access, network connections, and system calls.\nCentralize and aggregate logs from various sources to facilitate centralized analysis and correlation. Tools like the Elastic Stack (ELK) or Splunk can help in efficiently managing and analyzing logs.\nRegularly review logs for suspicious activities, such as unusual process behavior or unexpected network connections.\nImplement Application Whitelisting: Fileless malware often relies on executing malicious code from memory or exploiting trusted applications. Implementing application whitelisting can help mitigate this risk:\nDefine a whitelist of approved applications that are allowed to execute on your Linux system. This restricts the execution of unauthorized or untrusted code.\nRegularly review and update the whitelist as needed. Remove any unnecessary or outdated applications from the list to minimize potential attack vectors.\nEmploy Behavior-Based Detection: Fileless malware often exhibits unusual behavior patterns. Implementing behavior-based detection mechanisms can help identify and mitigate such threats:\nUtilize security solutions that employ behavior-based detection techniques. These solutions monitor system activities, process execution, and memory usage to detect suspicious behavior indicative of fileless malware.\nLeverage intrusion detection and prevention systems (IDS/IPS) to monitor network traffic and detect any malicious activities, such as command-and-control communications or data exfiltration.\nEducate and Train Users: End-user education and training play a crucial role in mitigating fileless malware risks. Train your employees and system users to:\nRecognize and avoid suspicious emails, phishing attempts, and social engineering techniques commonly used to deliver fileless malware.\nExercise caution when executing commands or running scripts, especially those received from unknown or untrusted sources.\nBy implementing these best practices and maintaining a proactive security stance, you can significantly enhance your Linux environment\u0026rsquo;s resilience against fileless malware. Regularly review and update your security measures to stay ahead of emerging threats and evolving attack techniques. Remember, a comprehensive defense strategy that combines technical controls, user education, and vigilant monitoring is key to effective fileless malware mitigation in your Linux environment.\nDetection Rules for Fileless Malware Falco is an open-source cloud-native runtime security tool that uses behavioral rules and real-time alerts to detect and prevent threats in Linux environments. With its powerful rule engine, Falco can help identify fileless malware attacks by monitoring system events and detecting suspicious activities. Here are a detection rule using auditd and Falco to idenfity fileless malware activity:\nAuditd Open the audit rules configuration file using a text editor: sudo vim /etc/audit/rules.d/audit.rules Add the following line to the file: -w /proc/self/mem -p wa -k fileless_malware_detection This rule monitors the /proc/self/mem file, which represents the process\u0026rsquo;s memory. It triggers an audit event whenever a write or attribute change occurs in the executable memory pages, indicating possible fileless malware activity.\nSave the file and exit the text editor.\nRestart the auditd service to apply the changes:\nsudo service auditd restart Falco Open the falco rules configuration file using a text editor: sudo nano /etc/falco/falco_rules.local.yaml Add the following macro and rule to the file: - rule: Detect suspicious process memory modifications desc: Detects modifications to process memory regions condition: \u0026gt; evt.type = mmap and evt.dir = \u0026gt; and evt.arg.prot IN (\u0026#34;PROT_EXEC\u0026#34;, \u0026#34;PROT_WRITE\u0026#34;) output: | # Event information evt_rawres=%evt.rawres, evt_type=%evt.type, evt_dir=%evt.dir, syscall_type=%syscall.type, evt_category=%evt.category, evt_args=%evt.args, # Process information proc_pid=%proc.pid, proc_exe=%proc.exe, proc_name=%proc.name, proc_args=%proc.args, proc_cmdline=%proc.cmdline, proc_exeline=%proc.exeline, proc_cwd=%proc.cwd, proc_nthreads=%proc.nthreads, proc_nchilds=%proc.nchilds, proc_ppid=%proc.ppid, proc_pname=%proc.pname, proc_pcmdline=%proc.pcmdline, proc_apid_2=%proc.apid[2], proc_aname_2=%proc.aname[2], proc_apid_3=%proc.apid[3], proc_aname_3=%proc.aname[3], proc_apid_4=%proc.apid[4], proc_aname_4=%proc.aname[4], proc_loginshellid=%proc.loginshellid, proc_duration=%proc.duration, proc_fdopencount=%proc.fdopencount, proc_vmsize=%proc.vmsize, proc_sid=%proc.sid, proc_sname=%proc.sname, proc_tty=%proc.tty, proc_exepath=%proc.exepath, proc_vpgid=%proc.vpgid, proc_is_exe_writable=%proc.is_exe_writable, # Threat information #thread_cap_permitted=%thread.cap_permitted, thread_cap_inheritable=%thread.cap_inheritable, thread_cap_effective=%thread.cap_effective, # File descriptor information fd_num=%fd.num, fd.type=%fd.type, fd_name=%fd.name, # User and group information user_uid=%user.uid, user_name=%user.name, user_homedir=%user.homedir, user_shell=%user.shell, user_loginuid=%user.loginuid, user_loginname=%user.loginname, group_gid=%group.gid, group_name=%group.name priority: WARNING This rule alerts when a process modifies memory permissions to allow write (w) or execute (x) access. Fileless malware often employs such techniques to execute code in memory without writing to disk.\nSave the file and exit the text editor.\nRestart the falco service to apply the changes:\nsudo service falco restart Note Make sure to configure Falco properly to ensure it captures the necessary system events and performs the desired detection. Adjust the rule according to your specific environment and monitoring needs.\nValidation Certainly! Here\u0026rsquo;s an example of C code that uses the mprotect system call to modify a process memory region to be executable:\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;sys/mman.h\u0026gt; int main() { // Allocate a buffer of 4KB size_t size = 4096; void* buffer = mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0); if (buffer == MAP_FAILED) { perror(\u0026#34;mmap\u0026#34;); return 1; } // Fill the buffer with some code unsigned char code[] = \u0026#34;\\x48\\x89\\xc7\\xc3\u0026#34;; // mov %rax, %rdi; ret memcpy(buffer, code, sizeof(code)); // Modify the memory protection to be executable if (mprotect(buffer, size, PROT_READ | PROT_EXEC) == -1) { perror(\u0026#34;mprotect\u0026#34;); return 1; } // Call the function in the modified memory region int result = ((int (*)())buffer)(); // Print the result printf(\u0026#34;Result: %d\\n\u0026#34;, result); // Free the allocated memory if (munmap(buffer, size) == -1) { perror(\u0026#34;munmap\u0026#34;); return 1; } return 0; } In this code, we use the mmap function to allocate a 4KB buffer with read and write permissions. We then copy some machine code into the buffer, representing a simple function that moves a value into a register and returns. After that, we use the mprotect function to modify the memory protection of the buffer, allowing it to be executed. Finally, we call the function in the modified memory region and print the result.\nPlease note that modifying process memory regions in this way can have unintended consequences and may violate system security policies. Ensure that you use this code responsibly and in controlled environments for testing or educational purposes only.\nBed Time Reading https://offlinemark.com/2021/05/12/an-obscure-quirk-of-proc/ "},{"section":"Blog","slug":"/blog/linux-core-dump/","title":"Unveiling the Secrets of Linux Core Dumps","description":"","date":"May 28, 2023","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/linux-core-dump/password-with-hand-holding-tweezers-binary-code_hu9009c3e40950ab36b989238b7140cc78_1190670_420x0_resize_q80_h2_lanczos.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"280\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/linux-core-dump\\/password-with-hand-holding-tweezers-binary-code_hu9009c3e40950ab36b989238b7140cc78_1190670_420x0_resize_q80_lanczos.jpg';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/linux-core-dump/password-with-hand-holding-tweezers-binary-code_hu9009c3e40950ab36b989238b7140cc78_1190670_100x100_fill_q80_h2_lanczos_smart1.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/linux-core-dump\\/password-with-hand-holding-tweezers-binary-code_hu9009c3e40950ab36b989238b7140cc78_1190670_100x100_fill_q80_lanczos_smart1.jpg';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"Security","tags":"Threat Detection, Linux, Core Dumps","content":"Understanding Core Dumps: Analysis of their Purpose and Risks A Linux core dump, also known as a core dump file, is a file that captures the memory contents of a running process when it encounters a critical error or crashes. It is a snapshot of the process\u0026rsquo;s memory at the time of the crash, including the values of variables, registers, and other relevant data. When a program crashes or terminates abnormally due to an error, the operating system generates a core dump file to help in debugging and understanding the cause of the crash. This file contains valuable information that can be analyzed to diagnose the issue and fix the software or identify vulnerabilities.\nThe core dump file is typically written to disk in a binary format but it can also be passed to a helper program (such as systemd-coredump(8)) for further processing. The memory image of the crashed process includes the program\u0026rsquo;s code, stack frames, heap data, and other relevant information. By examining the core dump, developers and security professionals can gain insights into the state of the program at the time of the crash, helping them identify bugs, memory corruption issues, or security vulnerabilities.\nTo analyze a core dump file, various debugging tools and techniques can be used. These tools allow the examination of memory regions, registers, and stack frames to understand the flow of the program before it crashed. Debuggers like GDB (GNU Debugger) are commonly used to load the core dump file and perform detailed analysis, including inspecting variables, stepping through the code, and examining memory regions.\nSecurity detection engineers may utilize core dumps as part of their investigations when analyzing incidents related to software crashes, exploits, or malicious activities. By examining the core dump, they can gather crucial information about the exploit or identify potential vulnerabilities that were exploited.\nIt\u0026rsquo;s worth noting that core dumps may contain sensitive information, such as passwords or encryption keys, depending on the state of the crashed process. Therefore, it\u0026rsquo;s important to handle core dump files with care, restrict access to authorized personnel, and ensure they are securely stored to prevent unauthorized access to sensitive data.\nThreat Actor Exploitation of Core Dumps In general, a core dump file itself does not pose a direct risk when it comes to threat actors using it maliciously. However, threat actors can potentially leverage the information contained within a core dump to aid in their attacks or exploit vulnerabilities. Here are a few scenarios where a threat actor might find value in a core dump:\nInformation Disclosure: If the core dump file contains sensitive information, such as passwords, API keys, or cryptographic keys, a threat actor could analyze the dump to extract and exploit that data.\nExploit Analysis: By examining a core dump, threat actors can gain insights into the inner workings of a crashed process. They can analyze the memory contents to identify vulnerabilities, memory corruption issues, or other weaknesses that could be exploited for their malicious activities.\nReverse Engineering: A threat actor may use a core dump file to reverse engineer the software and understand its internal structure, algorithms, or proprietary protocols. This knowledge can be leveraged to craft more sophisticated attacks or develop exploits targeting specific vulnerabilities.\nDebugging Exploits: Core dumps provide detailed information about the state of a crashed process, including register values, stack traces, and memory contents. Threat actors can use this information to debug their exploits, fine-tune their attack techniques, or identify potential weaknesses to bypass security measures.\nThreat Actor Techniques: How They Force Core Dumps In the realm of cybersecurity, threat actors continuously devise new methods to achieve their malicious objectives. One technique they may employ is to force a core dump on a targeted system. In this section, we will explore how threat actors can force core dumps and the potential risks associated with these actions.\nMethod 1: Exploiting Vulnerabilities One common approach utilized by threat actors involves exploiting software vulnerabilities. By identifying weaknesses in applications or the underlying operating system, they can trigger crashes or abnormal terminations intentionally. Vulnerabilities such as memory corruption, buffer overflow, or programming errors may serve as entry points. Through targeted exploitation, threat actors can force a process to crash, ultimately leading to the generation of a core dump.\nMethod 2: Resource Exhaustion Another technique is to exhaust system resources deliberately. By overwhelming a specific process or the system as a whole, threat actors can cause a crash scenario. Excessive consumption of memory, CPU, or other critical resources can result in an abnormal termination, triggering the creation of a core dump.\nMethod 3: Signal Injection Threat actors may manipulate vulnerable applications to generate specific signals, such as the SIGSEGV (segmentation fault) signal. This signal, when injected, causes a process to terminate abruptly. By exploiting the application\u0026rsquo;s vulnerability to signal injection, threat actors can induce a crash scenario and prompt the system to generate a core dump.\nMethod 4: Debugging Tools Abuse If a threat actor gains unauthorized access to a system or compromises a privileged account, they may abuse debugging tools that allow core dump generation. Debuggers like GDB (GNU Debugger) or similar utilities can be misused to force crashes, intercept signals, or manipulate the target process\u0026rsquo;s behavior. Through such manipulation, threat actors can trigger core dump creation.\nMitigation Strategies To effectively eradicate the threat associated with core dump files falling into the wrong hands, it is important to implement a combination of preventive measures and incident response practices. Here are some steps you can take:\nAccess Controls: Implement strong access controls to restrict access to core dump files. Only authorized personnel should have permission to access and analyze these files. Regularly review and update access privileges to ensure they align with the principle of least privilege.\nSecure Storage and Encryption: Store core dump files in a secure location, such as a dedicated and protected directory or server, with proper encryption in place. Encryption adds an extra layer of protection, especially if the files are stored or transferred over untrusted networks.\nData Sanitization: Before sharing or analyzing core dump files, ensure sensitive data within the dumps, such as passwords, keys, or personally identifiable information (PII), is removed or obfuscated. This can be achieved by scrubbing or sanitizing the dumps using appropriate tools or techniques.\nIncident Response Planning: Develop a comprehensive incident response plan specifically tailored to address incidents involving core dump files. This plan should outline the steps to be taken when a core dump is compromised or potentially accessed by unauthorized parties.\nMonitoring and Detection: Implement robust monitoring and detection mechanisms to identify any unauthorized access attempts or suspicious activities related to core dump files. This can include intrusion detection systems, log analysis, and security event monitoring.\nRegular Auditing and Review: Conduct regular audits and reviews of the access logs, storage locations, and security measures related to core dump files. This helps ensure that security controls are functioning as intended and any vulnerabilities or misconfigurations are promptly addressed.\nEmployee Awareness and Training: Provide training and awareness programs to employees involved in handling core dump files. Educate them about the importance of securing and handling these files properly, including the risks associated with their exposure and the best practices to mitigate those risks.\nThreat Detection Rules Rather than emphasizing commands that generate core dumps, shift your focus to what can create a core dump, e.g. consider the list of signals that trigger core dump creation in a process, e.g. SIGABRT. [2, 3]. However, not all monitoring tools are equipped to handle such intricate levels of detail. As an alternative, you can take advantage of /proc/self/coredump_filter. The /proc/self/coredump_filter file is used in Linux systems to control the types of information that are included in a core dump file when a process crashes. It allows a process to specify which memory segments and resources should be included or excluded from the core dump. Before generating the core dump, the operating system checks the settings in the /proc/self/coredump_filter file to determine which memory segments and resources should be included in the core dump, e.g. openat(AT_FDCWD, \u0026ldquo;/proc/1688715/coredump_filter\u0026rdquo;, O_RDONLY|O_CLOEXEC) = 14. The operating system reads the bitmask specified in the file to understand the process\u0026rsquo;s preferences for the contents of the core dump. Based on the settings in the coredump_filter file, the operating system includes or excludes the corresponding memory segments and resources when creating the core dump file.\nAuditd To detect when a process reads its own core dump filter settings, we will leverage the power of auditd, the Linux auditing framework. Follow these steps to create the FIM rule:\nOpen the audit rules configuration file using a text editor: sudo vim /etc/audit/rules.d/audit.rules Add the following line to the file: -w /proc/self/coredump_filter -p r -k coredump_filter_read This rule instructs auditd to monitor the file /proc/self/coredump_filter for read operations (-p r). When a process reads this file, an audit event will be generated and labeled with the key coredump_filter_read (-k coredump_filter_read).\nSave the file and exit the text editor.\nRestart the auditd service to apply the changes:\nsudo service auditd restart Falco Falco is a powerful open-source cloud-native runtime security tool that enables real-time threat detection and response. Here\u0026rsquo;s an example of a Falco rule that can detect when a process reads the /proc/self/coredump_filter file:\nOpen the falco rules configuration file using a text editor: sudo nano /etc/falco/falco_rules.local.yaml Add the following macro and rule to the file: - macro: open_read condition: (evt.type in (open,openat,openat2) and evt.is_open_read=true and fd.typechar=\u0026#39;f\u0026#39; and fd.num\u0026gt;=0) - rule: Core dump file created desc: \u0026gt; Identifies attempts to create a core dump file. enabled: true condition: \u0026gt; evt.category=file and open_read and fd.name = \u0026#34;/proc/self/coredump_filter\u0026#34; output: | # Event information evt_rawres=%evt.rawres, evt_type=%evt.type, evt_dir=%evt.dir, syscall_type=%syscall.type, evt_category=%evt.category, evt_args=%evt.args, # Process information proc_pid=%proc.pid, proc_exe=%proc.exe, proc_name=%proc.name, proc_args=%proc.args, proc_cmdline=%proc.cmdline, proc_exeline=%proc.exeline, proc_cwd=%proc.cwd, proc_nthreads=%proc.nthreads, proc_nchilds=%proc.nchilds, proc_ppid=%proc.ppid, proc_pname=%proc.pname, proc_pcmdline=%proc.pcmdline, proc_apid_2=%proc.apid[2], proc_aname_2=%proc.aname[2], proc_apid_3=%proc.apid[3], proc_aname_3=%proc.aname[3], proc_apid_4=%proc.apid[4], proc_aname_4=%proc.aname[4], proc_loginshellid=%proc.loginshellid, proc_duration=%proc.duration, proc_fdopencount=%proc.fdopencount, proc_vmsize=%proc.vmsize, proc_sid=%proc.sid, proc_sname=%proc.sname, proc_tty=%proc.tty, proc_exepath=%proc.exepath, proc_vpgid=%proc.vpgid, proc_is_exe_writable=%proc.is_exe_writable, # Threat information #thread_cap_permitted=%thread.cap_permitted, thread_cap_inheritable=%thread.cap_inheritable, thread_cap_effective=%thread.cap_effective, # File descriptor information fd_num=%fd.num, fd.type=%fd.type, fd_name=%fd.name, # User and group information user_uid=%user.uid, user_name=%user.name, user_homedir=%user.homedir, user_shell=%user.shell, user_loginuid=%user.loginuid, user_loginname=%user.loginname, group_gid=%group.gid, group_name=%group.name priority: WARNING tags: [filesystem, mitre_credential_access, mitre_discovery] Save the file and exit the text editor.\nRestart the falco service to apply the changes:\nsudo service falco restart Note Make sure to configure Falco properly to ensure it captures the necessary system events and performs the desired detection. Adjust the rule according to your specific environment and monitoring needs.\nValidation Once you have implemented a FIM rule to detect process access to the /proc/self/coredump_filter file, it is essential to verify that the detection logic is functioning correctly. In this section, we will walk you through the steps to test the detection logic of the rule and ensure that it generates the expected output when a process reads the core dump filter file. Regularly testing and validating your security monitoring rules is crucial to ensure that your system remains protected against unauthorized or suspicious activities.\nStep 1: Preparing the Environment\nBefore testing the rule, ensure that you have Falco or auditd properly installed and running on your system. Refer to the tool documentation for guidance on installation and configuration specific to your environment.\nStep 2: Performing the Test\nTo test the detection logic, execute the following commands:\nsleep 300 \u0026amp; PID=$! kill -s SIGSEGV \u0026#34;$PID\u0026#34; Step 3: Analyze Results\nAnalyze the output generated by the detection logic and compare it against the expected results for the test scenario. Determine whether the detection logic accurately detects the simulated threat and creates and audit record and provides an appropriate alert.\nBed Time Reading https://wiki.archlinux.org/title/Core_dump https://man7.org/linux/man-pages/man5/core.5.html https://man7.org/linux/man-pages/man7/signal.7.html https://linux-audit.com/understand-and-configure-core-dumps-work-on-linux/#disable-core-dumps "},{"section":"Blog","slug":"/blog/detection-rule-effectiveness/","title":"Maximizing Threat Detection Rule Effectiveness","description":"","date":"March 10, 2023","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/detection-rule-effectiveness/rules_performace_metrics_hud1a3ce88938303133d3e5a32be266f2a_1761785_420x0_resize_q80_h2_lanczos.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"277\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/detection-rule-effectiveness\\/rules_performace_metrics_hud1a3ce88938303133d3e5a32be266f2a_1761785_420x0_resize_q80_lanczos.jpeg';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/detection-rule-effectiveness/rules_performace_metrics_hud1a3ce88938303133d3e5a32be266f2a_1761785_100x100_fill_q80_h2_lanczos_smart1.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/detection-rule-effectiveness\\/rules_performace_metrics_hud1a3ce88938303133d3e5a32be266f2a_1761785_100x100_fill_q80_lanczos_smart1.jpeg';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"Security","tags":"Threat Detection, Rule, Metrics","content":"Maximizing Threat Detection Rule Effectiveness As security detection engineers, we constantly strive to enhance the effectiveness of our threat detection rules. While constructing a confusion matrix from the Security Incident Response Team (SIRT) investigation\u0026rsquo;s dispositions—true positives, benign events, and false positives—provides insights, it\u0026rsquo;s crucial to establish robust performance metrics for a comprehensive assessment.\nUnderstanding the Challenge Threat detection rules operate in a binary classification problem, categorizing events as malicious or benign. However, the imbalance in data sources—where the negative class significantly outweighs the positive class—necessitates careful selection of evaluation metrics. Metrics relying heavily on true negative results may not accurately reflect real-world performance.\nPerformance Metrics for Detection Rules False Negative Rate The false negative rate quantifies the proportion of malicious behavior that eluded detection. Think of it as the fraction of fraudulent transactions missed by our model. If the consequences of letting fraudulent transactions slip through are substantial, and the value derived from users isn\u0026rsquo;t significant, focusing on minimizing this number becomes crucial. Our goal is clear: optimize the false negative rate to 0% to ensure we capture all malicious activity.\nFalse Discovery Rate The false discovery rate measures the proportion of incorrect evaluations among all rule matches. Increasing false alerts consumes valuable time, and we want all positive matches to merit investigation. Therefore, our aim is to optimize for precision, ensuring that each positive match is indeed worth examining.\nRecall | Sensitivity | True Positive Rate Recall reflects the proportion of correctly identified rule matches. It answers the question: How many fraudulent transactions did we correctly recall out of all fraudulent transactions? Recall becomes pivotal when catching all fraudulent transactions is paramount, even at the cost of some false alerts. If recall is lower, it implies we\u0026rsquo;re missing true positive results due to incorrect or over-tuned detection logic. Our target is to optimize recall to 100% to ensure we identify all malicious activity.\nPrecision | Positive Predictive Value Precision reveals the ratio of correctly classified positive identifications. In the context of fraud detection, precision indicates the proportion of transactions correctly labeled as fraudulent. When optimizing precision, we want to ensure that those we deem guilty are truly so. Our goal is to optimize precision to 95%, striking a balance between identifying all malicious activity and ensuring positive predictions warrant scrutiny.\nFbeta Score The Fbeta score amalgamates precision and recall into a single metric. A higher Fbeta score signifies better detection rule performance. The choice of beta in the Fbeta score reflects our prioritization between recall and precision. For instance, with an F2 score, recall is twice as important as precision. Our objective is to optimize the F2 score to 95%, emphasizing the importance of recall while maintaining a high level of precision.\nEvaluating Performance and Defining Tune Priorities Once we\u0026rsquo;ve established the key performance metrics for our detection rules, the next step is to evaluate their performance and define tune priorities. By categorizing rule performance and prioritizing optimization efforts, we can effectively allocate resources and enhance our threat detection rules.\nPerformance Rank Tune Priority Conditions Description Good - False Negative Rate = 0 \u0026amp;\u0026amp; False Discovery Rate \u0026lt; 0.05 \u0026amp;\u0026amp; F2 score \u0026gt;= 0.95 The detection rule is capturing all true positive results, with a very low rate of false positive results. Average High False Negative Rate = 0 \u0026amp;\u0026amp; False Discovery Rate \u0026gt; 0.05 \u0026amp;\u0026amp; F2 score \u0026gt;= 0.95 The detection rule is capturing all true positive results, but is creating some false positive results. Poor Critical (False Discovery Rate \u0026gt; 0.05 || Precision \u0026lt; 0.95) \u0026amp;\u0026amp; F2 score \u0026lt; 0.95 The detection rule is underperforming. Bad Urgent False Negative Rate \u0026gt; 0 ||\nFalse Discovery Rate = 1 ||\nF2 score \u0026gt;= 0.95 \u0026amp;\u0026amp; (False Discovery Rate \u0026gt; 0.05 || Precision \u0026lt; 0.95) The detection rule is missing true positive results.\nThe detection rule only created false positive results.\nThe detection rule is creating a high percentage of false positive results. In conclusion, by adopting a systematic approach to performance evaluation and optimization, we enhance the effectiveness of our threat detection rules. Establishing clear priorities based on performance evaluations empowers us to allocate resources efficiently and address deficiencies proactively. Through continuous improvement, we fortify our security posture and stay resilient against evolving threats.\nBed Time Reading Classification: Accuracy Precision and recall 24 Evaluation Metrics for Binary Classification (And When to Use Them) "}]