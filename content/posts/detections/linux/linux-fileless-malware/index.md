---
title: Invisible Intruders - Unmasking the Stealthy World of Fileless Malware
date: 2023-06-4
# description: Unveiling the Secrets of Linux Core Dumps
menu:
  sidebar:
    name: Invisible Intruders - Unmasking the Stealthy World of Fileless Malware
    identifier: linux-fileless-malware
    parent: linux
    weight: 10
hero: fileless-malware.jpeg
mermaid: true
tags: ["Threat Detection", "Linux", "Malware"]
categories: ["security"]
---

In the ever-evolving landscape of cyber threats, malware continues to be a significant concern for individuals and organizations alike. Traditional malware often relies on files to carry out malicious activities. However, a couple of years ago a new breed of malware known as "fileless malware" has emerged, posing a formidable challenge to cybersecurity professionals. In this blog post, we will explore the concept of fileless malware, discuss threat actors utilizing it, delve into their techniques, and discover methods to detect fileless malware on Linux systems.

## What is Fileless Malware?

Fileless malware refers to a type of malicious software that does not rely on traditional file-based components to infect and persist on a victim's system. Unlike conventional malware that typically relies on executable files or scripts stored on disk, fileless malware operates by leveraging legitimate system tools and processes already present on the target system. It resides solely in the computer's memory or uses existing system utilities to execute malicious actions, making it difficult to detect and eradicate.

Fileless malware takes advantage of various techniques to carry out its malicious activities while minimizing its footprint on the compromised system. Here are some common characteristics and techniques associated with fileless malware:

1. Memory-based Execution: Fileless malware operates in the computer's memory, leveraging scripting languages, macros, or other memory-resident techniques to execute its payload. By avoiding disk-based files, it reduces the likelihood of detection by traditional antivirus software that primarily scans for file-based threats.

2. Living off the Land: Fileless malware exploits trusted system tools, processes, and utilities already present on the compromised system. It abuses legitimate software such as PowerShell, Windows Management Instrumentation (WMI), or command-line interpreters to carry out its malicious activities. This technique makes it challenging to distinguish between normal and malicious system behavior.

3. Code Injection and Registry Persistence: Instead of dropping files on disk, fileless malware injects its code directly into legitimate processes running in memory. It can also modify system registries to achieve persistence, ensuring that the malware remains active even after a system reboot.

4. Exploiting Vulnerabilities: Fileless malware often exploits vulnerabilities in software or operating systems to gain initial access to a system. It can use techniques like remote code execution, privilege escalation, or phishing attacks to deliver the payload and establish a foothold.

5. Credential Theft and Lateral Movement: Once fileless malware infects a system, it focuses on extracting sensitive information, such as usernames, passwords, or cryptographic keys. It may use techniques like keylogging, memory scraping, or pass-the-hash attacks to harvest credentials. Subsequently, it can leverage these credentials to move laterally across the network, infecting additional systems.

Fileless malware poses significant challenges for traditional security solutions due to its evasive nature and reliance on legitimate system components. Detecting and mitigating fileless malware requires a multi-layered approach that includes behavioral analysis, anomaly detection, monitoring of system activities, and the use of specialized security tools designed to detect memory-based threats.

## Unmasking the Culprits: Threat Actor Groups Leveraging Fileless Malware

Fileless malware has become a favorite weapon in the arsenals of various threat actor groups, allowing them to launch stealthy and sophisticated attacks. In this section, we'll delve into some of the notable threat actor groups that have been leveraging fileless malware as part of their nefarious activities.

1. APT28 (Fancy Bear):
   Known for its association with the Russian government, APT28, also known as Fancy Bear, has demonstrated advanced capabilities in carrying out cyber espionage campaigns. This threat actor group has been observed employing fileless malware to infiltrate high-profile targets and compromise sensitive information. Their sophisticated techniques make detection and attribution challenging.

2. Lazarus Group:
   Hailing from North Korea, the Lazarus Group has gained infamy for its involvement in high-profile cyber attacks. This threat actor group has adopted fileless malware as a stealthy approach to breach financial institutions and cryptocurrency exchanges. Their goal is often financial gain, and they employ advanced tactics to evade detection and cover their tracks.

3. APT32 (OceanLotus):
   APT32, also known as OceanLotus, is a sophisticated threat actor group originating from Vietnam. This group primarily targets Southeast Asian countries, with a focus on government entities, dissidents, and corporate organizations. APT32 has been observed utilizing fileless malware in their campaigns, allowing them to bypass traditional security measures and maintain persistence within compromised systems.

4. APT34 (OilRig):
   Hailing from Iran, APT34, also known as OilRig, is a well-known threat actor group that conducts cyber espionage activities. This group has been attributed to various campaigns targeting critical infrastructure, energy sectors, and government organizations. APT34 has incorporated fileless malware into its tactics, enabling them to infiltrate networks, gather intelligence, and maintain long-term access.

5. APT40 (Periscope):
   APT40, also referred to as Periscope, is a Chinese threat actor group with a focus on maritime industries, specifically targeting entities involved in the South China Sea disputes. This group has been observed employing fileless malware to compromise maritime organizations, gaining access to sensitive data and strategic information. Their activities pose significant risks to national security and regional stability.

These are just a few examples of threat actor groups that have embraced fileless malware as part of their malicious campaigns. The evolving landscape of cyber threats necessitates continuous vigilance and proactive defense measures to mitigate the risks posed by these sophisticated adversaries.

## Sneaky Techniques: How Threat Actor Groups Utilize Fileless Malware

Fileless malware has become an integral component of the toolkit used by various threat actor groups. In this section, we'll uncover the sneaky techniques employed by these adversaries when utilizing fileless malware, shedding light on their modus operandi and the challenges faced by security professionals.

1. Living Off the Land:
   One of the primary techniques employed by threat actors using fileless malware is "living off the land." This involves leveraging legitimate processes, tools, and functionalities already present in the targeted system to carry out their malicious activities. By exploiting trusted applications and system utilities, such as PowerShell, Windows Management Instrumentation (WMI), or Linux command-line tools, threat actors can execute malicious code directly in memory, leaving little to no trace on the file system.

2. Exploiting Vulnerabilities:
   Threat actor groups also capitalize on software vulnerabilities to deploy fileless malware. They actively search for security flaws in popular applications, operating systems, or even firmware, allowing them to exploit these weaknesses and gain unauthorized access. Once inside the system, they can inject their malicious code into legitimate processes or memory areas without relying on traditional file-based payloads.

3. Script-Based Attacks:
   Scripting languages like PowerShell and JavaScript provide threat actors with powerful capabilities to execute commands and automate tasks. These languages are often used to deliver fileless malware payloads, as they can run directly in memory, evading traditional antivirus and endpoint detection mechanisms. By embedding malicious scripts within seemingly harmless documents or leveraging social engineering techniques, threat actors trick users into executing the scripts, initiating the infection chain.

4. Memory Injection and Code Staging:
   Another technique utilized by threat actors involves memory injection and code staging. Instead of relying on traditional file-based payloads, they inject their malicious code directly into the memory space of legitimate processes. This enables them to execute their code within the context of trusted applications, making detection and analysis more challenging. By using code staging techniques, threat actors can further obfuscate their activities by encrypting or decrypting their payloads in memory, adding an extra layer of complexity.

5. Fileless Persistence Mechanisms:
   Maintaining persistence is crucial for threat actors to ensure prolonged access to compromised systems. Fileless malware allows them to establish persistence without leaving traces on the file system. They achieve this by employing various techniques, such as registry modifications, scheduled tasks, or service hijacking, to ensure their malicious code is executed during system startup or at specific intervals. By leveraging these fileless persistence mechanisms, threat actors can maintain control over the compromised system for an extended period.

Detecting and mitigating fileless malware poses significant challenges for security professionals. Traditional antivirus solutions often rely on file-based scanning, making them ineffective against fileless attacks. To combat these stealthy threats, specialized security tools and techniques, such as behavior-based detection, memory analysis, and anomaly detection, are crucial for detecting and responding to fileless malware incidents.

In the next section, we will explore strategies and best practices to help organizations enhance their defenses against fileless malware attacks, empowering them to proactively protect their systems and data.

## Mitigating Fileless Malware in Your Linux Environment: Best Practices

As fileless malware continues to evolve and pose a significant threat to systems, it's crucial to implement effective mitigation strategies specifically tailored for Linux environments. Linux, being a popular operating system in both server and desktop environments, requires diligent measures to protect against fileless malware attacks. In this section, we will explore some key practices to help you mitigate fileless malware in your Linux environment.

1. Harden Your Linux System:
   To mitigate fileless malware attacks, start by hardening your Linux system's security posture. This includes:

   - Regularly updating your operating system and installed software to ensure you have the latest security patches. Vulnerabilities in software components can be exploited by fileless malware to gain access to the system.

   - Disable unnecessary services and protocols to reduce the attack surface. Only enable the services that are essential for your system's functionality.

   - Employ strong authentication mechanisms, such as multi-factor authentication (MFA), to prevent unauthorized access to your system.

2. Monitor System Activities:
   Implementing robust monitoring and logging capabilities is crucial for detecting and responding to fileless malware. Consider the following practices:

   - Enable auditing and logging features provided by your Linux distribution. This includes logging process execution, file access, network connections, and system calls.

   - Centralize and aggregate logs from various sources to facilitate centralized analysis and correlation. Tools like the Elastic Stack (ELK) or Splunk can help in efficiently managing and analyzing logs.

   - Regularly review logs for suspicious activities, such as unusual process behavior or unexpected network connections.

3. Implement Application Whitelisting:
   Fileless malware often relies on executing malicious code from memory or exploiting trusted applications. Implementing application whitelisting can help mitigate this risk:

   - Define a whitelist of approved applications that are allowed to execute on your Linux system. This restricts the execution of unauthorized or untrusted code.

   - Regularly review and update the whitelist as needed. Remove any unnecessary or outdated applications from the list to minimize potential attack vectors.

4. Employ Behavior-Based Detection:
   Fileless malware often exhibits unusual behavior patterns. Implementing behavior-based detection mechanisms can help identify and mitigate such threats:

   - Utilize security solutions that employ behavior-based detection techniques. These solutions monitor system activities, process execution, and memory usage to detect suspicious behavior indicative of fileless malware.

   - Leverage intrusion detection and prevention systems (IDS/IPS) to monitor network traffic and detect any malicious activities, such as command-and-control communications or data exfiltration.

5. Educate and Train Users:
   End-user education and training play a crucial role in mitigating fileless malware risks. Train your employees and system users to:

   - Recognize and avoid suspicious emails, phishing attempts, and social engineering techniques commonly used to deliver fileless malware.

   - Exercise caution when executing commands or running scripts, especially those received from unknown or untrusted sources.

By implementing these best practices and maintaining a proactive security stance, you can significantly enhance your Linux environment's resilience against fileless malware. Regularly review and update your security measures to stay ahead of emerging threats and evolving attack techniques. Remember, a comprehensive defense strategy that combines technical controls, user education, and vigilant monitoring is key to effective fileless malware mitigation in your Linux environment.

## Detection Rules for Fileless Malware

Falco is an open-source cloud-native runtime security tool that uses behavioral rules and real-time alerts to detect and prevent threats in Linux environments. With its powerful rule engine, Falco can help identify fileless malware attacks by monitoring system events and detecting suspicious activities. Here are a detection rule using auditd and Falco to idenfity fileless malware activity:

### Auditd

1. Open the audit rules configuration file using a text editor:

```bash
sudo vim /etc/audit/rules.d/audit.rules
```

2. Add the following line to the file:

```bash
-w /proc/self/mem -p wa -k fileless_malware_detection
```

This rule monitors the `/proc/self/mem` file, which represents the process's memory. It triggers an audit event whenever a write or attribute change occurs in the executable memory pages, indicating possible fileless malware activity.

3. Save the file and exit the text editor.

4. Restart the auditd service to apply the changes:

```bash
sudo service auditd restart
```

### Falco

1. Open the falco rules configuration file using a text editor:

```bash
sudo nano /etc/falco/falco_rules.local.yaml
```

2. Add the following macro and rule to the file:

```
- rule: Detect suspicious process memory modifications
  desc: Detects modifications to process memory regions
  condition: >
    evt.type = mmap
    and evt.dir = >
    and evt.arg.prot IN ("PROT_EXEC", "PROT_WRITE")
  output: |
    # Event information
    evt_rawres=%evt.rawres, evt_type=%evt.type, evt_dir=%evt.dir, syscall_type=%syscall.type, evt_category=%evt.category, evt_args=%evt.args,
    # Process information
    proc_pid=%proc.pid, proc_exe=%proc.exe, proc_name=%proc.name, proc_args=%proc.args, proc_cmdline=%proc.cmdline, proc_exeline=%proc.exeline, proc_cwd=%proc.cwd, proc_nthreads=%proc.nthreads, proc_nchilds=%proc.nchilds, proc_ppid=%proc.ppid, proc_pname=%proc.pname, proc_pcmdline=%proc.pcmdline, proc_apid_2=%proc.apid[2], proc_aname_2=%proc.aname[2], proc_apid_3=%proc.apid[3], proc_aname_3=%proc.aname[3], proc_apid_4=%proc.apid[4], proc_aname_4=%proc.aname[4], proc_loginshellid=%proc.loginshellid, proc_duration=%proc.duration, proc_fdopencount=%proc.fdopencount, proc_vmsize=%proc.vmsize, proc_sid=%proc.sid, proc_sname=%proc.sname, proc_tty=%proc.tty, proc_exepath=%proc.exepath, proc_vpgid=%proc.vpgid, proc_is_exe_writable=%proc.is_exe_writable,
    # Threat information
    #thread_cap_permitted=%thread.cap_permitted, thread_cap_inheritable=%thread.cap_inheritable, thread_cap_effective=%thread.cap_effective,
    # File descriptor information
    fd_num=%fd.num, fd.type=%fd.type, fd_name=%fd.name,
    # User and group information
    user_uid=%user.uid, user_name=%user.name, user_homedir=%user.homedir, user_shell=%user.shell, user_loginuid=%user.loginuid, user_loginname=%user.loginname, group_gid=%group.gid, group_name=%group.name
  priority: WARNING
```

This rule alerts when a process modifies memory permissions to allow write (`w`) or execute (`x`) access. Fileless malware often employs such techniques to execute code in memory without writing to disk.

3. Save the file and exit the text editor.

4. Restart the falco service to apply the changes:

```bash
sudo service falco restart
```

> **Note**
> Make sure to configure Falco properly to ensure it captures the necessary system events and performs the desired detection. Adjust the rule according to your specific environment and monitoring needs.

## Validation

Certainly! Here's an example of C code that uses the `mprotect` system call to modify a process memory region to be executable:

```c
#include <stdio.h>
#include <string.h>
#include <sys/mman.h>

int main() {
    // Allocate a buffer of 4KB
    size_t size = 4096;
    void* buffer = mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
    if (buffer == MAP_FAILED) {
        perror("mmap");
        return 1;
    }

    // Fill the buffer with some code
    unsigned char code[] = "\x48\x89\xc7\xc3";  // mov %rax, %rdi; ret
    memcpy(buffer, code, sizeof(code));

    // Modify the memory protection to be executable
    if (mprotect(buffer, size, PROT_READ | PROT_EXEC) == -1) {
        perror("mprotect");
        return 1;
    }

    // Call the function in the modified memory region
    int result = ((int (*)())buffer)();

    // Print the result
    printf("Result: %d\n", result);

    // Free the allocated memory
    if (munmap(buffer, size) == -1) {
        perror("munmap");
        return 1;
    }

    return 0;
}
```

In this code, we use the `mmap` function to allocate a 4KB buffer with read and write permissions. We then copy some machine code into the buffer, representing a simple function that moves a value into a register and returns. After that, we use the `mprotect` function to modify the memory protection of the buffer, allowing it to be executed. Finally, we call the function in the modified memory region and print the result.

Please note that modifying process memory regions in this way can have unintended consequences and may violate system security policies. Ensure that you use this code responsibly and in controlled environments for testing or educational purposes only.

## Bed Time Reading

1. https://offlinemark.com/2021/05/12/an-obscure-quirk-of-proc/
